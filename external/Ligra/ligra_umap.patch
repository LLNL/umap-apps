diff --git a/apps/BFS.C b/apps/BFS.C
index 241b8ca..09623dc 100644
--- a/apps/BFS.C
+++ b/apps/BFS.C
@@ -21,6 +21,9 @@
 // LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//#include "profiler.hh"
+//Profiler profiler;
+
 #include "ligra.h"
 
 struct BFS_F {
@@ -39,6 +42,7 @@ struct BFS_F {
 
 template <class vertex>
 void Compute(graph<vertex>& GA, commandLine P) {
+  
   long start = P.getOptionLongValue("-r",0);
   long n = GA.n;
   //creates Parents array, initialized to all -1, except for start
@@ -46,11 +50,21 @@ void Compute(graph<vertex>& GA, commandLine P) {
   parallel_for(long i=0;i<n;i++) Parents[i] = UINT_E_MAX;
   Parents[start] = start;
   vertexSubset Frontier(n,start); //creates initial frontier
+  //profiler.start_all();
   while(!Frontier.isEmpty()){ //loop until frontier is empty
     vertexSubset output = edgeMap(GA, Frontier, BFS_F(Parents));    
     Frontier.del();
     Frontier = output; //set new frontier
-  } 
+  }
+  //profiler.stop_all();
+  //profiler.view_all();
   Frontier.del();
+
+#ifdef VERIFY
+  printf("\n[");
+  for(long i=0;i<n;i++) printf("%lu ",Parents[i]);
+  printf("]\n");
+#endif
+
   free(Parents); 
 }
diff --git a/apps/Makefile b/apps/Makefile
index 819ae7e..7e509e3 100644
--- a/apps/Makefile
+++ b/apps/Makefile
@@ -1,10 +1,17 @@
-ifdef LONG
+UMAP_ROOT=/home/peng8/umap_multitier/umap_old
+UMAP_ROOT=/mimer/NOBACKUP/groups/snic2022-5-307/ip/umap
+UMAP_ROOT=/home/peng8/umap_multitier/umap_new
+
+UMAP_INSTALL=${UMAP_ROOT}/build
+PFM_INSTALL=/home/peng8/skylake/Software/perfmon2-libpfm4
+
+#ifdef LONG
 INTT = -DLONG
-endif
+#endif
 
-ifdef EDGELONG
+#ifdef EDGELONG
 INTE = -DEDGELONG
-endif
+#endif
 
 ifdef PD
 PD = -DPD
@@ -22,33 +29,43 @@ ifdef LOWMEM
 MEM = -DLOWMEM
 endif
 
+#Opt 1: -DVERIFY -DCREATE_MMAP_FILE
+#Opt 2: -DMEM_MAP -DUSE_MMAP
+#Opt 3: -DMEM_MAP -DUSE_UMAP
+#-I$(UMAP_ROOT)/ext/profiling/pebs/include 
+#-lboost_system -lboost_thread -L${PFM_INSTALL}/lib -lpfm -lnuma -L$(UMAP_ROOT)/ext/profiling/pebs/lib -lpebs 
+#OPT= -DMEM_MAP -DMMAP -I$(UMAP_INSTALL)/include  $(INTT) $(INTE) $(CODE) $(PD) $(MEM)
+OPT= -DMEM_MAP -DUSE_UMAP -I$(UMAP_INSTALL)/include  $(INTT) $(INTE) $(CODE) $(PD) $(MEM)
+PLFLAGS=$(UMAP_INSTALL)/lib/libumap.so
+
 #compilers
-ifdef CILK
-PCC = g++
-PCFLAGS = -std=c++14 -fcilkplus -lcilkrts -O3 -DCILK $(INTT) $(INTE) $(CODE) $(PD) $(MEM)
-PLFLAGS = -fcilkplus -lcilkrts
+#ifdef CILK
+#PCC = g++
+#PCFLAGS = -std=c++14 -fcilkplus -lcilkrts -O3 -DCILK $(OPT)
+#PLFLAGS += -fcilkplus -lcilkrts
 
-else ifdef MKLROOT
-PCC = icpc
-PCFLAGS = -std=c++14 -O3 -DCILKP $(INTT) $(INTE) $(CODE) $(PD) $(MEM)
+#else ifdef MKLROOT
+#PCC = icpc
+#PCFLAGS = -std=c++14 -O3 -DCILKP $(OPT) 
 
-else ifdef OPENMP
+#else #ifdef OPENMP
 PCC = g++
-PCFLAGS = -std=c++14 -fopenmp -march=native -O3 -DOPENMP $(INTT) $(INTE) $(CODE) $(PD) $(MEM)
+PCFLAGS = -std=c++14 -Wno-unused-result -fopenmp -march=native -O3 -DOPENMP $(OPT)
 
-else
-PCC = g++
-PCFLAGS = -std=c++14 -O3 $(INTT) $(INTE) $(CODE) $(PD) $(MEM)
-endif
+#else
+#PCC = g++
+#PCFLAGS = -std=c++14 -O3 $(OPT)
+#endif
 
-COMMON= ligra.h graph.h compressedVertex.h vertex.h utils.h IO.h parallel.h gettime.h index_map.h maybe.h sequence.h edgeMap_utils.h binary_search.h quickSort.h blockRadixSort.h transpose.h parseCommandLine.h byte.h byteRLE.h nibble.h byte-pd.h byteRLE-pd.h nibble-pd.h vertexSubset.h encoder.C decoder.C
+COMMON= ligra.h graph.h compressedVertex.h vertex.h utils.h IO.h IOumap.h parallel.h gettime.h index_map.h maybe.h sequence.h edgeMap_utils.h binary_search.h quickSort.h blockRadixSort.h transpose.h parseCommandLine.h byte.h byteRLE.h nibble.h byte-pd.h byteRLE-pd.h nibble-pd.h vertexSubset.h encoder.C decoder.C
 
-ALL= encoder decoder BFS BC BellmanFord Components Components-Shortcut Radii PageRank PageRankDelta BFSCC BFS-Bitvector KCore MIS Triangle CF
+#ALL= encoder decoder BFS BC BellmanFord Components Components-Shortcut Radii PageRank PageRankDelta BFSCC BFS-Bitvector KCore MIS Triangle CF
+ALL= BFS
 
 all: $(ALL)
 
 % : %.C $(COMMON)
-	$(PCC) $(PCFLAGS) -o $@ $<
+	$(PCC) $(PCFLAGS) -o $@ $< $(PLFLAGS)
 
 $(COMMON):
 	ln -s ../ligra/$@ .
@@ -56,8 +73,8 @@ $(COMMON):
 .PHONY : clean
 
 clean :
-	rm -f *.o $(ALL)
+	rm -f *.o $(ALL) *~
 
 cleansrc :
-	rm -f *.o $(ALL)
-	rm $(COMMON)
+	rm -f *.o $(ALL) *~
+	rm -f $(COMMON)
diff --git a/apps/PageRank.C b/apps/PageRank.C
index c40d438..24d843d 100644
--- a/apps/PageRank.C
+++ b/apps/PageRank.C
@@ -68,7 +68,7 @@ struct PR_Vertex_Reset {
 
 template <class vertex>
 void Compute(graph<vertex>& GA, commandLine P) {
-  long maxIters = P.getOptionLongValue("-maxiters",100);
+  long maxIters = P.getOptionLongValue("-maxiters",2); //100
   const intE n = GA.n;
   const double damping = 0.85, epsilon = 0.0000001;
   
@@ -96,5 +96,12 @@ void Compute(graph<vertex>& GA, commandLine P) {
     vertexMap(Frontier,PR_Vertex_Reset(p_curr));
     swap(p_curr,p_next);
   }
+
+#ifdef VERIFY
+  printf("\n[");
+  for(long i=0;i<n;i++) printf("%.6f ", p_next[i]);
+  printf("]\n");
+#endif
+  
   Frontier.del(); free(p_curr); free(p_next); 
 }
diff --git a/apps/generate_input.sh b/apps/generate_input.sh
new file mode 100644
index 0000000..d163665
--- /dev/null
+++ b/apps/generate_input.sh
@@ -0,0 +1,39 @@
+#!/bin/bash
+
+
+#Creates symmetric rMAT graphs
+
+./rMatGraph -s 1048576 /l/ssd/ligra_rMat_s_n20
+./rMatGraph -s 67108864 /l/ssd/ligra_rMat_s_n26
+./rMatGraph -s 134217728 /l/ssd/ligra_rMat_s_n27
+./rMatGraph -s 268435456 /l/ssd/ligra_rMat_s_n28
+./rMatGraph -s 536870912 /l/ssd/ligra_rMat_s_n29
+./rMatGraph -s 1073741824 /l/ssd/ligra_rMat_s_n30
+./rMatGraph -s 2147483648 /l/ssd/ligra_rMat_s_n31
+
+
+
+#Convert real-world graphs into symmetric graphs
+#SNAPtoAdj converts a graph in SNAP format and converts it to Ligra's adjacency graph format
+
+# LJ
+wget http://snap.stanford.edu/data/soc-LiveJournal1.txt.gz
+gunzip soc-LiveJournal1.txt.gz
+./SNAPtoAdj -s soc-LiveJournal1.txt /mnt/pmem/pm1/soc-LiveJournal1
+
+# CP
+wget http://snap.stanford.edu/data/cit-Patents.txt.gz
+gunzip cit-Patents.txt.gz
+./SNAPtoAdj -s cit-Patents.txt /mnt/pmem/pm1/cit-Patents
+
+# FT
+wget http://snap.stanford.edu/data/bigdata/communities/com-friendster.ungraph.txt.gz
+gunzip com-friendster.ungraph.txt.gz
+./SNAPtoAdj -s com-friendster.ungraph.txt /mnt/pmem/pm1/com-friendster
+
+# TW
+wget https://suitesparse-collection-website.herokuapp.com/MM/SNAP/twitter7.tar.gz
+#http://sparse-files.engr.tamu.edu/MM/SNAP/twitter7.tar.gz
+tar -xzvf /mnt/pmem/pm0/twitter7.tar.gz
+./SNAPtoAdj -s /mnt/pmem/pm0/twitter7.txt /mnt/pmem/pm0/twitter7
+
diff --git a/apps/memory_setup.sh b/apps/memory_setup.sh
new file mode 100644
index 0000000..125a51a
--- /dev/null
+++ b/apps/memory_setup.sh
@@ -0,0 +1,145 @@
+#!/bin/bash
+
+function free_mem {
+    m=`grep MemFree /proc/meminfo | awk -v N=2 '{print $N}'`
+    fm=$(((${m}/1024)/1024))
+    echo ${fm}" GB Free on the system"
+}
+
+function avail_mem {
+    m=`grep MemAvail /proc/meminfo | awk -v N=2 '{print $N}'`
+    fm=$(((${m}/1024)/1024))
+    echo ${fm}" GB Free on the system"
+}
+
+function drop_page_cache {
+    echo "Dropping page cache"
+    sudo sh -c "/usr/bin/echo 3 > /proc/sys/vm/drop_caches"
+    #/home/perma/drop_buffer_cache
+    #srun --drop-caches=pagecache hostname
+}
+
+function system_info {
+  uname -a
+}
+
+function test_setup {
+  #drop_page_cache
+  avail_mem
+  numactl -H
+  system_info
+}
+
+function waste_memory_1 {
+    free=`numactl -H | grep "node 1 free:" | awk '{print $4}'`
+    echo ${free}" MB free on NUMA node 1"
+    waste=$(( free / 1024 - 10 ))
+    echo "Wasting $waste GB of memory"
+    if [ $waste > 0 ]
+    then
+	echo dd if=/dev/zero of=/dev/shm/${waste}GB bs=4096 count=$((${waste}*256*1024))
+	numactl -C 1 -N 1 dd if=/dev/zero of=/dev/shm/${waste}GB bs=4096 count=$((${waste}*256*1024))
+    fi
+}
+function waste_memory_0 {
+    free=`numactl -H | grep "node 0 free:" | awk '{print $4}'`
+    echo ${free}" MB free on NUMA node 0"
+    waste=$(( free / 1024 - 10 ))
+    echo "Wasting $waste GB of memory"
+    if [ $waste > 0 ]
+    then
+	echo dd if=/dev/zero of=/dev/shm/${waste}GB bs=1M count=$((${waste}*1000))
+	dd if=/dev/zero of=/dev/shm/${waste}GB bs=1M count=$((${waste}*1000))
+    fi
+}
+
+function waste_memory_old {
+    m=`grep MemFree /proc/meminfo | awk -v N=2 '{print $N}'`
+    fm=$(((${m}/1024)))
+    echo ${fm}" MB Free on the system"
+    waste=$(( fm / 1024 - 50 ))
+    echo "Wasting $waste GB of memory"
+    if [ $waste > 0 ]
+    then
+	echo dd if=/dev/zero of=/dev/shm/${waste}GB bs=4096 count=$((${waste}*256*1024))
+	dd if=/dev/zero of=/dev/shm/${waste}GB bs=4096 count=$((${waste}*256*1024))
+    fi
+}
+
+function amounttowaste {
+  m=`grep MemFree /proc/meminfo | awk -v N=2 '{print $N}'`
+  fm=$(((${m}/1024)/1024))
+  waste=$((${fm}-${memtoleave}))
+  echo $fm GB Available, Wasting $waste GB
+}
+
+#test_setup
+drop_page_cache
+waste_memory_0
+#waste_memory_1
+test_setup
+exit
+
+umap_lib=/home/peng8/umap/build/lib
+ld_path="${umap_lib}:/home/peng8/skylake/Software/perfmon2-libpfm4/lib:/home/peng8/umap/ext/profiling/pebs/lib:${LD_LIBRARY_PATH}"
+input_dir=/mnt/pmem/pm0/ligra
+
+declare -a graph_arr=(
+    "ligra_rMat_s_n20"
+    "ligra_rMat_s_n26"
+    "ligra_rMat_s_n27"
+    "ligra_rMat_s_n28"
+    "ligra_rMat_s_n29"
+    "com-friendster"
+    "com-orkut"
+    "soc-LiveJournal1"
+    "soc-pokec"
+    "cit-Patents"
+)
+
+declare -a source_arr=(
+    "0"
+    "0"
+    "0"
+    "0"
+    "0"
+    "101"
+    "1"
+    "0"
+    "1"
+    "3858241"
+)
+
+len=5 #${#graph_arr[@]}
+#numa_setup=" numactl --membind=1 --cpunodebind=1 "
+
+for i in $(seq 4 $((len-1)))
+do
+    input="${graph_arr[$i]}"
+    root="${source_arr[$i]}"
+
+    for app in BFS #BC Radii Components PageRank
+    do
+        exe=${app}
+        output=${exe}_${input}.log
+        test_setup > ${output}
+        cmd="env LD_LIBRARY_PATH=${ld_path} ${numa_setup} ./${exe} -maxiters 1 -s -m -r $root ${input_dir}/${input}" #>> ${output}"
+        echo $cmd #>> ${output}
+        #eval $cmd
+        continue
+
+        exe=${app}"_umap"
+        for psize in 16384 32768 65536 131072 262144 524288 1048576
+        do
+            output=numax2_${exe}_${input}_psize${psize}.log
+            test_setup > ${output}
+            #cmd="env UMAP_PAGESIZE=${psize} LD_LIBRARY_PATH=${ld_path} numactl --membind=1 --cpunodebind=1 ./${exe} -s -m ${input_pref}${s} >> ${output}"
+            cmd="env UMAP_PAGESIZE=${psize} LD_LIBRARY_PATH=${ld_path} ./${exe} -maxiters 1 -s -m -r $root ${input_dir}/${input} >> ${output}"
+            echo $cmd >> ${output}
+            eval $cmd
+        done
+    done
+done
+
+echo "Done"
+    
diff --git a/apps/run_all.sh b/apps/run_all.sh
new file mode 100644
index 0000000..ee458a7
--- /dev/null
+++ b/apps/run_all.sh
@@ -0,0 +1,108 @@
+#!/bin/bash
+
+function free_mem {
+    m=`grep MemFree /proc/meminfo | awk -v N=2 '{print $N}'`
+    fm=$(((${m}/1024)/1024))
+    echo $fm GB Free
+}
+
+function drop_page_cache {
+    echo "Dropping page cache"
+    sudo sh -c "/usr/bin/echo 3 > /proc/sys/vm/drop_caches"
+    #/home/perma/drop_buffer_cache
+    #srun --drop-caches=pagecache hostname
+}
+
+function system_info {
+  uname -a
+}
+
+function test_setup {
+  drop_page_cache
+  free_mem
+  numactl -H
+  system_info
+}
+
+function waste_memory {
+    free=`numactl -H | grep "node 1 free:" | awk '{print $4}'`
+    echo $free
+    waste=$(( free / 1024 - 24 ))
+    echo "Wasting $waste GB of memory"
+    echo dd if=/dev/zero of=/dev/shm/${waste}GB bs=4096 count=$((${waste}*256*1024))
+    numactl -C 1 -N 1 dd if=/dev/zero of=/dev/shm/${waste}GB bs=4096 count=$((${waste}*256*1024))
+}
+
+function amounttowaste {
+  m=`grep MemFree /proc/meminfo | awk -v N=2 '{print $N}'`
+  fm=$(((${m}/1024)/1024))
+  waste=$((${fm}-${memtoleave}))
+  echo $fm GB Available, Wasting $waste GB
+}
+
+#waste_memory
+#test_setup
+
+umap_lib=../../../build/lib
+ld_path="${umap_lib}:/home/peng8/skylake/Software/perfmon2-libpfm4/lib:../../../ext/pebs/lib:${LD_LIBRARY_PATH}"
+input_dir=/mnt/pmem/pm0/ligra
+
+declare -a graph_arr=(
+    "ligra_rMat_s_n20"
+    "ligra_rMat_s_n26"
+    "ligra_rMat_s_n27"
+    "ligra_rMat_s_n28"
+    "ligra_rMat_s_n29"
+    "com-friendster"
+    "com-orkut"
+    "soc-LiveJournal1"
+    "soc-pokec"
+    "cit-Patents"
+)
+
+declare -a source_arr=(
+    "0"
+    "0"
+    "0"
+    "0"
+    "0"
+    "101"
+    "1"
+    "0"
+    "1"
+    "3858241"
+)
+
+len=2 #${#graph_arr[@]}
+#numa_setup=" numactl --membind=1 --cpunodebind=1 "
+
+for i in $(seq 1 $((len-1)))
+do
+    input="${graph_arr[$i]}"
+    root="${source_arr[$i]}"
+
+    for app in BFS #BC Radii Components PageRank
+    do
+        exe=${app}
+        output=${exe}_${input}.log
+        #test_setup > ${output}
+        cmd="env LD_LIBRARY_PATH=${ld_path} ${numa_setup} ./${exe} -maxiters 1 -s -m -r $root ${input_dir}/${input}" #>> ${output}"
+        echo $cmd #>> ${output}
+        #eval $cmd
+        continue
+
+        exe=${app}"_umap"
+        for psize in 16384 32768 65536 131072 262144 524288 1048576
+        do
+            output=numax2_${exe}_${input}_psize${psize}.log
+            test_setup > ${output}
+            #cmd="env UMAP_PAGESIZE=${psize} LD_LIBRARY_PATH=${ld_path} numactl --membind=1 --cpunodebind=1 ./${exe} -s -m ${input_pref}${s} >> ${output}"
+            cmd="env UMAP_PAGESIZE=${psize} LD_LIBRARY_PATH=${ld_path} ./${exe} -maxiters 1 -s -m -r $root ${input_dir}/${input} >> ${output}"
+            echo $cmd >> ${output}
+            #eval $cmd
+        done
+    done
+done
+
+echo "Done"
+    
diff --git a/apps/run_parser.sh b/apps/run_parser.sh
new file mode 100644
index 0000000..9b481cd
--- /dev/null
+++ b/apps/run_parser.sh
@@ -0,0 +1,44 @@
+#!/bin/bash
+
+for input in ligra_rMat_s_n26 ligra_rMat_s_n27 ligra_rMat_s_n28 ligra_rMat_s_n29 com-friendster com-orkut soc-LiveJournal1 soc-pokec cit-Patents
+do
+    for app in BFS BC Radii Components PageRank
+    do
+	exe=${app}"_mmap"
+	output=numax2_${exe}_${input}.log
+	echo $output
+	grep --max-count=1 "Running time " $output | awk '{print $4}'
+
+	exe=${app}"_umap"
+	for psize in 16384 32768 65536 131072 262144 524288 1048576
+	do
+	    output=numax2_${exe}_${input}_psize${psize}.log
+	    grep --max-count=1 "Running time " $output | awk '{print $4}'
+	done
+	echo ""
+    done
+done
+
+echo "Done"
+exit
+    
+
+for s in 24 25 26 27 28 29
+do
+    exe="bfs_mmap"
+    #output=numa1_pmem1_cpu1_${exe}_s${s}.log
+    output=numax2_${exe}_s${s}.log
+    grep --max-count=1 "Running time " $output | awk '{print $4}'
+
+    exe="bfs_umap"
+    for psize in 16384 32768 65536 131072 262144 524288 1048576
+    do
+	#output=numa1_pmem1_cpu1_${exe}_psize${psize}_s${s}.log
+	output=numax2_${exe}_psize${psize}_s${s}.log
+	grep --max-count=1 "Running time " $output | awk '{print $4}'
+    done
+    echo ""
+done
+
+echo "Done"
+    
diff --git a/apps/run_profiling.sh b/apps/run_profiling.sh
new file mode 100644
index 0000000..2e01134
--- /dev/null
+++ b/apps/run_profiling.sh
@@ -0,0 +1,18 @@
+#!/bin/bash
+
+umap_lib=/home/peng8/skylake/ligra/umap/build_profiler/lib
+ld_path="${umap_lib}:${LD_LIBRARY_PATH}"
+input_pref=/mnt/pmem/pm1
+input=com-friendster
+
+for app in BFS #BC Radii Components PageRank 
+do
+    exe=${app}_umap
+    output=profile_${exe}_umapbuf5GB_24omp_${input}.log
+    cmd="env LD_LIBRARY_PATH=${ld_path} OMP_NUM_THREADS=24 UMAP_PAGESIZE=4096 UMAP_BUFSIZE=1310720 ./${exe} -maxiters 1 -s -m -r 101  ${input_pref}/${input} > ${output}"
+    echo $cmd
+    #eval $cmd
+done
+
+echo "Done"
+    
diff --git a/apps/test_tmpfs.sh b/apps/test_tmpfs.sh
new file mode 100644
index 0000000..96ca234
--- /dev/null
+++ b/apps/test_tmpfs.sh
@@ -0,0 +1,30 @@
+#!/bin/bash
+
+
+#function setuptmpfs {
+  if [ ! -d /mnt/tmpfs ]; then
+    mkdir -p /mnt/tmpfs
+  fi
+
+  # Unmount / Reset of already mounted
+  fs=`stat -f -c '%T' /mnt/tmpfs`
+
+  if [ "$fs" = "tmpfs" ]; then
+    echo "Resetting tmpfs"
+    umount /mnt/tmpfs
+  fi
+
+  fs=`stat -f -c '%T' /mnt/tmpfs`
+  if [ "$fs" != "tmpfs" ]; then
+    if [ ! -d /mnt/tmpfs ]; then
+      mkdir -p /mnt/tmpfs
+    fi
+    chmod go+rwx /mnt/tmpfs
+    mount -t tmpfs -o size=48g tmpfs /mnt/tmpfs
+    fs=`stat -f -c '%T' /mnt/tmpfs`
+    echo "/mnt/tmpfs mounted as: $fs"
+  else
+    echo "Unable to reset /mnt/tmpfs, exiting"
+    exit 1
+  fi
+#}
diff --git a/ligra/IO.h b/ligra/IO.h
index e31dfc6..0abcde5 100644
--- a/ligra/IO.h
+++ b/ligra/IO.h
@@ -555,3 +555,4 @@ graph<vertex> readCompressedGraph(char* fname, bool isSymmetric, bool mmap) {
   graph<vertex> G(V,n,m,mem);
   return G;
 }
+
diff --git a/ligra/IOumap.h b/ligra/IOumap.h
new file mode 100644
index 0000000..d58c3b9
--- /dev/null
+++ b/ligra/IOumap.h
@@ -0,0 +1,395 @@
+// This code is part of the project "Ligra: A Lightweight Graph Processing
+// Framework for Shared Memory", presented at Principles and Practice of
+// Parallel Programming, 2013.
+// Copyright (c) 2013 Julian Shun and Guy Blelloch
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights (to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+#include "umap/umap.h"
+#define MEM_MAP_WITH_UMAP 1
+#define MEM_MAP_WITH_MMAP 2
+
+_seq<char> memmapFromFileOffset(const char *filename, off_t offset, size_t length, void* addr, int mem_map_option)
+{
+  struct stat sb;
+  int flags = O_RDWR; //O_RDONLY  O_RDWR
+  if( mem_map_option == MEM_MAP_WITH_UMAP )
+    flags |= O_DIRECT;
+
+  int fd = open(filename, flags);
+  if (fd == -1) {
+    perror("open");
+    exit(-1);
+  }
+  if (fstat(fd, &sb) == -1) {
+    perror("fstat");
+    exit(-1);
+  }
+  if (!S_ISREG (sb.st_mode)) {
+    perror("not a file\n");
+    exit(-1);
+  }
+
+  if( addr && munmap(addr, length) == -1){
+    printf("munmap to specified address at %p \n failed",addr);
+    exit(-1);
+  }
+
+  char *p;
+  if( mem_map_option == MEM_MAP_WITH_MMAP )
+  {
+    p = static_cast<char*>(mmap(addr, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, offset));
+    if (p == MAP_FAILED) {
+      perror("mmap failed");
+      exit(-1);
+    }
+    cout << "mmapped at " << (void*)p << endl;
+    if (close(fd) == -1) {
+      perror("close failed");
+      exit(-1);
+    }
+  }else{
+    uint64_t umap_pagesize = umapcfg_get_umap_page_size();
+    length = ((length-1)/umap_pagesize + 1 )*umap_pagesize;
+    p = static_cast<char*>(umap(addr, length, PROT_READ, UMAP_PRIVATE, fd, offset)); //|PROT_WRITE
+    if (p == UMAP_FAILED) {
+      perror("umap failed");
+      exit(-1);
+    }
+    //if(length<=4295229440UL) umap_fetch_and_pin(p, length);
+    cout << "umapped at " << (void*)p << endl;
+  }
+  
+  //profiler.mt_register_address((void*)p, length);
+
+  //for Ligra, it needs to be mapped exactly to the requested virtual address
+  if( addr && p!=addr ){
+    printf("failed to be mapped to %p (%p)\n", addr, p);
+    exit(-1);
+  }
+  
+  return _seq<char>(p, length);
+}
+
+template <class vertex>
+graph<vertex> readUncompressedGraph(char* iFile, bool symmetric, bool binary, bool mmap) {
+  if(binary) 
+    return readGraphFromBinary<vertex>(iFile,symmetric);
+  else 
+    return readGraphFromFile<vertex>(iFile,symmetric,mmap);
+}
+
+template <class vertex>
+graph<vertex> generateCompressedSymmetricGraphStoreFromBinary(char* fname) 
+{
+  return NULL;
+}
+
+template <class vertex>
+graph<vertex> generateCompressedSymmetricGraphStoreFromFile(char* fname) 
+{
+  return NULL;
+}
+
+template <class vertex>
+graph<vertex> generateUncompressedSymmetricGraphStoreFromBinary(char* fname) 
+{
+  return NULL;
+}
+
+template <class symmetricVertex>
+void generateUncompressedSymmetricGraphStoreFromFile(char* fname) 
+{ 
+  printf("generateUncompressedSymmetricGraphStoreFromFile:: start\n");
+  string s(fname);
+  std::string ss_path(s);
+
+  words W;
+  _seq<char> S = readStringFromFile(fname);
+  W = stringToWords(S.A, S.n);
+#ifndef WEIGHTED
+  if (W.Strings[0] != (string) "AdjacencyGraph")
+#else
+  if (W.Strings[0] != (string) "WeightedAdjacencyGraph")
+#endif
+  {
+    cout << "Bad input file" << endl;
+    abort();
+  }
+
+  long len = W.m -1;
+  long n = atol(W.Strings[1]);
+  long m = atol(W.Strings[2]);
+#ifndef WEIGHTED
+  if (len != n + m + 2)
+#else
+  if (len != n + 2*m + 2)
+#endif
+  {
+    cout << "Bad input file" << endl;
+    abort();
+  }else{
+    printf("generateUncompressedSymmetricGraphStoreFromFile:: n = %ld m=%ld\n", n, m);
+  }
+
+
+  uintT* offsets = newA(uintT,n);
+#ifndef WEIGHTED
+  uintE* edges = newA(uintE,m);
+#else
+  intE* edges = newA(intE,2*m);
+#endif
+
+
+  {parallel_for(long i=0; i < n; i++) offsets[i] = atol(W.Strings[i + 3]);}
+  {parallel_for(long i=0; i<m; i++) {
+#ifndef WEIGHTED
+      edges[i] = atol(W.Strings[i+n+3]);
+#else
+      edges[2*i] = atol(W.Strings[i+n+3]);
+      edges[2*i+1] = atol(W.Strings[i+n+m+3]);
+#endif
+    }}
+  //W.del(); // to deal with performance bug in malloc
+
+  symmetricVertex* v = newA(symmetricVertex,n);
+
+  {parallel_for (uintT i=0; i < n; i++) {
+    uintT o = offsets[i];
+    uintT l = ((i == n-1) ? m : offsets[i+1])-offsets[i];
+    v[i].setOutDegree(l);
+#ifndef WEIGHTED
+    v[i].setOutNeighbors(edges+o);
+#else
+    v[i].setOutNeighbors(edges+2*o);
+#endif
+    }}
+
+  free(offsets);
+
+  /*
+    Start CREATE_MMAP_FILE, the following saves graph edge structure into a file
+  */
+  std::stringstream ss_fname_edge;
+  ss_fname_edge << ss_path << ".edge";
+  const std::string str_edge = ss_fname_edge.str();
+  const char*     fname_edge = str_edge.c_str();
+  FILE * fp = fopen(fname_edge, "wb"); //write binary
+  if (fp == NULL)  /* If an error occurs during the file creation */
+  {
+     cerr << "fopen() failed for " << fname_edge <<endl;
+     exit(0);
+  }
+
+  fseek(fp, 0, SEEK_SET);
+#ifndef WEIGHTED
+  size_t elements_written = fwrite(edges, sizeof(uintE), m, fp); 
+  if (elements_written != m )
+    cerr << "fwrite(edges) failed" << endl;
+  fseek(fp, sizeof(uintE)*m, SEEK_SET);
+#else
+  size_t elements_written = fwrite(edges, sizeof(uintE), m*2, fp); 
+  if (elements_written != m*2 )
+    cerr << "fwrite(weigthed edges) failed" << endl;
+  fseek(fp, sizeof(uintE)*m*2, SEEK_SET);
+#endif
+
+
+  elements_written = fwrite(&m, sizeof(long), 1, fp); 
+  if (elements_written != 1)
+    cerr << "fwrite(m) failed "<<endl;
+
+  //fseek(fp, sizeof(uintE)*m+sizeof(long), SEEK_SET);
+  fseek(fp, 0L, SEEK_CUR);
+  elements_written = fwrite(&n, sizeof(long), 1, fp); 
+  if (elements_written != 1)
+    cerr << "fwrite(n) failed "<<endl;
+
+  //fseek(fp, sizeof(uintE)*m+sizeof(long)*2, SEEK_SET);
+  fseek(fp, 0L, SEEK_CUR);
+  uint64_t edges_ptr = (uint64_t) edges;
+  elements_written = fwrite(&edges_ptr, sizeof(uint64_t), 1, fp); 
+  if (elements_written != 1)
+    cerr << "fwrite(edges_ptr) failed "<<endl;
+
+  //truncate the file size
+  //fseek(fp, sizeof(uintE)*m+sizeof(long)*2+sizeof(uint64_t), SEEK_SET);
+  fseek(fp, 0L, SEEK_CUR);
+  fputc('\0', fp);
+  fclose(fp);
+
+    
+  /*
+    Start saving graph vertex structure into a file
+  */
+  std::stringstream ss_fname_vertex;
+  ss_fname_vertex << ss_path << ".vertex";
+  const std::string str_vertex = ss_fname_vertex.str();
+  const char*     fname_vertex = str_vertex.c_str();
+  fp = fopen(fname_vertex, "wb"); //write binary
+  if (fp == NULL)  /* If an error occurs during the file creation */
+  {
+     cerr << "fopen(vertex) failed for " << fname_vertex <<endl;
+     exit(0);
+  }
+  fseek(fp, 0, SEEK_SET);
+  elements_written = fwrite(v, sizeof(symmetricVertex), n, fp); 
+  if (elements_written != n )
+    cerr << "fwrite(vertex) failed" <<endl;
+  
+  //fseek(fp, sizeof(vertex)*n, SEEK_SET);
+  fseek(fp, 0L, SEEK_CUR);
+  uint64_t vertex_ptr = (uint64_t) v;
+  elements_written = fwrite(&vertex_ptr, sizeof(uint64_t), 1, fp); 
+  if (elements_written != 1)
+    cerr << "fwrite(vertex_ptr) failed "<<endl;
+
+  //truncate the file size
+  //fseek(fp, sizeof(vertex)*n+sizeof(uint64_t), SEEK_SET);
+  fseek(fp, 0L, SEEK_CUR);
+  fputc('\0', fp);
+  fclose(fp);
+
+}
+
+template <class vertex>
+graph<vertex> memmapUncompressedSymmetricGraphStoreFromFile(char* fname, int mem_map_option) 
+{
+
+  string s(fname);
+  std::string ss_path(s);
+
+  // Graph Edge datastore
+  std::stringstream ss_edge;
+  ss_edge << ss_path << ".edge";
+  const std::string str_edge = ss_edge.str();
+  const char* fname_edge     = str_edge.c_str();
+
+  /*
+    Start of reading the graph metadata from edge file/datastore : num_edges, num_vertices, edge_ptr
+  */
+  FILE *fp = fopen(fname_edge, "rb");
+  int fd = open(fname_edge, O_RDONLY);
+  struct stat sb;
+  if (fd == -1) {
+    perror("open");
+    exit(-1);
+  }
+  if (fstat(fd, &sb) == -1) {
+    perror("fstat");
+    exit(-1);
+  }
+
+  off_t offset = sb.st_size - 1 - (sizeof(long)*2+sizeof(uint64_t));
+  //cout << "edge file_size " << sb.st_size << " offset " << offset << endl;
+
+  long buffer[2];
+  fseek(fp, offset, SEEK_SET);
+  fread(buffer, sizeof(long), 2, fp);
+  size_t num_edges    = buffer[0];
+  size_t num_vertices = buffer[1];
+
+  // check the file size and the number of edges are consistent
+  if (offset != num_edges*sizeof(uintE)) {
+    cerr << "edge file validation failed, compiled with wrong options?" << endl
+         << "file offset " << offset << ", expected " << num_edges*sizeof(uintE) << endl;
+    exit(1);
+  }
+
+  // read in the saved edge pointer
+  fseek(fp, offset+sizeof(long)*2, SEEK_SET);
+  uint64_t edge_ptr;
+  fread(&edge_ptr, sizeof(uint64_t), 1, fp);
+  void* p = (void*) edge_ptr;
+  fclose(fp);
+
+  /*
+    Start of reading the graph metadata from vertex file/datastore : vertex_ptr
+  */
+  std::stringstream ss_vertex;
+  ss_vertex << ss_path << ".vertex";
+  const std::string str_vertex = ss_vertex.str();
+  const char*  fname_vertex    = str_vertex.c_str();
+
+  fp = fopen(fname_vertex, "rb");
+  fd = open(fname_vertex, O_RDONLY);
+  if (fd == -1) {
+    perror("open");
+    exit(-1);
+  }
+  if (fstat(fd, &sb) == -1) {
+    perror("fstat");
+    exit(-1);
+  }
+    
+  // check the file size and the number of vertices are consistent
+  size_t total_vertex_bytes = sb.st_size - 1 - sizeof(uint64_t);
+  size_t element_bytes = sizeof(symmetricVertex);
+  if ( total_vertex_bytes % element_bytes || total_vertex_bytes/element_bytes != num_vertices ) {
+    cerr << "vertex file validation failed" << endl
+         << "total_vertex_bytes " << total_vertex_bytes << ", expected " << num_vertices*element_bytes << endl;
+    exit(1);
+  }
+
+  // read in the saved vertex pointer
+  fseek(fp, sb.st_size -1 -sizeof(uint64_t), SEEK_SET);
+  uint64_t vertex_ptr;
+  fread(&vertex_ptr, sizeof(uint64_t), 1, fp);
+  void* v_p = (void*) vertex_ptr;
+
+  fclose(fp);
+
+  /*
+    Start of memory-mapping vertex and edge datastores
+  */
+  size_t edge_region_size = sizeof(uintE) * num_edges;
+  off_t  edge_file_offset = 0;
+
+  _seq<char> seq_edge = memmapFromFileOffset(fname_edge, edge_file_offset, edge_region_size, p, mem_map_option);
+  uintE *edge_region  = (uintE*) seq_edge.A;
+  if (edge_region == MAP_FAILED) {
+    perror("mmap");
+    exit(-1);
+  }
+  printf("Mem-mapped edges to %p of %lu bytes \n", edge_region, edge_region_size);
+
+
+  size_t vertice_region_size = sizeof(symmetricVertex) * num_vertices;
+  size_t vertice_file_offset = 0;
+  _seq<char> seq_vertex = memmapFromFileOffset(fname_vertex, vertice_file_offset, vertice_region_size, NULL, mem_map_option);//vertex does not need to be mapped to the same address
+  symmetricVertex* vertex_region = (symmetricVertex*) seq_vertex.A;
+  if (vertex_region == MAP_FAILED) {
+    perror("mmap");
+    exit(-1);
+  }
+  printf("Mem-mapped vertex to %p of %lu bytes \n", vertex_region, vertice_region_size);
+
+  long n = num_vertices;
+  long m = num_edges;
+  uintE* edges = (uintE*) edge_region;
+  symmetricVertex* v = (symmetricVertex*) vertex_region;
+
+  Uncompressed_Mem<vertex>* mem = new Uncompressed_Mem<vertex>(v,n,m,edges);
+  cout << "Mem-map Uncompressed Symmetric UNWEIGHTED AdjacencyGraph, edges(m)=" << m <<", vertices(n)=" << n << endl;
+
+  return graph<vertex>(v,n,m,mem);
+
+}
diff --git a/ligra/ligra.h b/ligra/ligra.h
index 4742e6e..74ffcef 100644
--- a/ligra/ligra.h
+++ b/ligra/ligra.h
@@ -40,6 +40,9 @@
 #include "parseCommandLine.h"
 #include "index_map.h"
 #include "edgeMap_utils.h"
+#ifdef USE_UMAP
+#include "IOumap.h"
+#endif
 using namespace std;
 
 //*****START FRAMEWORK*****
@@ -470,14 +473,21 @@ template<class vertex>
 void Compute(hypergraph<vertex>&, commandLine);
 
 int parallel_main(int argc, char* argv[]) {
+
+
   commandLine P(argc,argv," [-s] <inFile>");
   char* iFile = P.getArgument(0);
   bool symmetric = P.getOptionValue("-s");
   bool compressed = P.getOptionValue("-c");
   bool binary = P.getOptionValue("-b");
   bool mmap = P.getOptionValue("-m");
-  //cout << "mmap = " << mmap << endl;
-  long rounds = P.getOptionLongValue("-rounds",3);
+  bool generate_only = P.getOptionValue("-g"); //generate datastore files for memory-map through mmap or umap later
+  bool map_with_umap = P.getOptionValue("-umap"); //memory map with UMap 
+  bool map_with_mmap = P.getOptionValue("-mmap"); //memory map with mmap
+  int  mem_map_option = 0;
+  if(map_with_umap) mem_map_option = 1;
+  else if(map_with_mmap) mem_map_option = 2;
+  long rounds = P.getOptionLongValue("-rounds",1);
   if (compressed) {
     if (symmetric) {
 #ifndef HYPER
@@ -514,20 +524,28 @@ int parallel_main(int argc, char* argv[]) {
     }
   } else {
     if (symmetric) {
+#ifdef USE_UMAP
+      if ( generate_only ){
+        generateUncompressedSymmetricGraphStoreFromFile<symmetricVertex>(iFile);
+        return 0;
+      }
+#endif
+      startTime();
 #ifndef HYPER
-      graph<symmetricVertex> G =
-        readGraph<symmetricVertex>(iFile,compressed,symmetric,binary,mmap); //symmetric graph
+      graph<symmetricVertex> G = (mem_map_option ? memmapUncompressedSymmetricGraphStoreFromFile<symmetricVertex>(iFile, mem_map_option) :
+                                 readGraph<symmetricVertex>(iFile,compressed,symmetric,binary,mmap)); //symmetric graph
 #else
       hypergraph<symmetricVertex> G =
         readHypergraph<symmetricVertex>(iFile,compressed,symmetric,binary,mmap); //symmetric graph
 #endif
-      Compute(G,P);
+      nextTime("pre-processing time");
+      Compute(G,P);nextTime("Running time");
       for(int r=0;r<rounds;r++) {
         startTime();
         Compute(G,P);
         nextTime("Running time");
       }
-      G.del();
+      //G.del();
     } else {
 #ifndef HYPER
       graph<asymmetricVertex> G =
diff --git a/ligra/utils.h b/ligra/utils.h
index 648888f..1d88e2a 100644
--- a/ligra/utils.h
+++ b/ligra/utils.h
@@ -42,7 +42,8 @@ static int __jj =  mallopt(M_TRIM_THRESHOLD,-1);
 typedef unsigned int uint;
 typedef unsigned long ulong;
 
-#define newA(__E,__n) (__E*) malloc((__n)*sizeof(__E))
+//#define newA(__E,__n) (__E*) malloc((__n)*sizeof(__E))
+#define newA(__E,__n) (__E*) ({void* buf = NULL; posix_memalign(&buf, 4194304, (__n)*sizeof(__E));buf;})
 
 template <class E>
 struct identityF { E operator() (const E& x) {return x;}};
diff --git a/utils/Makefile b/utils/Makefile
index ff71785..9db551d 100644
--- a/utils/Makefile
+++ b/utils/Makefile
@@ -16,13 +16,13 @@ else ifdef MKLROOT
 PCC = icpc
 PCFLAGS = -std=c++14 -O3 -DCILKP $(INTT) $(INTE)
 
-else ifdef OPENMP
+else #ifdef OPENMP
 PCC = g++
-PCFLAGS = -std=c++14 -fopenmp -march=native -O3 -DOPENMP $(INTT) $(INTE)
+PCFLAGS = -g -std=c++14 -fopenmp -march=native -O3 -DOPENMP $(INTT) $(INTE)
 
-else
-PCC = g++
-PCFLAGS = -std=c++14 -O3 $(INTT) $(INTE)
+#else
+#PCC = g++
+#PCFLAGS = -std=c++14 -O3 $(INTT) $(INTE)
 endif
 
 COMMON = utils.h parseCommandLine.h parallel.h quickSort.h blockRadixSort.h transpose.h
@@ -39,7 +39,7 @@ $(COMMON):
 	$(PCC) $(PCFLAGS) -o $@ $<
 
 clean :
-	rm -f *.o $(GENERATORS)
+	rm -f *.o $(GENERATORS) *~
 
 cleansrc :
 	make -s clean
diff --git a/utils/generate_input.sh b/utils/generate_input.sh
new file mode 100644
index 0000000..d163665
--- /dev/null
+++ b/utils/generate_input.sh
@@ -0,0 +1,39 @@
+#!/bin/bash
+
+
+#Creates symmetric rMAT graphs
+
+./rMatGraph -s 1048576 /l/ssd/ligra_rMat_s_n20
+./rMatGraph -s 67108864 /l/ssd/ligra_rMat_s_n26
+./rMatGraph -s 134217728 /l/ssd/ligra_rMat_s_n27
+./rMatGraph -s 268435456 /l/ssd/ligra_rMat_s_n28
+./rMatGraph -s 536870912 /l/ssd/ligra_rMat_s_n29
+./rMatGraph -s 1073741824 /l/ssd/ligra_rMat_s_n30
+./rMatGraph -s 2147483648 /l/ssd/ligra_rMat_s_n31
+
+
+
+#Convert real-world graphs into symmetric graphs
+#SNAPtoAdj converts a graph in SNAP format and converts it to Ligra's adjacency graph format
+
+# LJ
+wget http://snap.stanford.edu/data/soc-LiveJournal1.txt.gz
+gunzip soc-LiveJournal1.txt.gz
+./SNAPtoAdj -s soc-LiveJournal1.txt /mnt/pmem/pm1/soc-LiveJournal1
+
+# CP
+wget http://snap.stanford.edu/data/cit-Patents.txt.gz
+gunzip cit-Patents.txt.gz
+./SNAPtoAdj -s cit-Patents.txt /mnt/pmem/pm1/cit-Patents
+
+# FT
+wget http://snap.stanford.edu/data/bigdata/communities/com-friendster.ungraph.txt.gz
+gunzip com-friendster.ungraph.txt.gz
+./SNAPtoAdj -s com-friendster.ungraph.txt /mnt/pmem/pm1/com-friendster
+
+# TW
+wget https://suitesparse-collection-website.herokuapp.com/MM/SNAP/twitter7.tar.gz
+#http://sparse-files.engr.tamu.edu/MM/SNAP/twitter7.tar.gz
+tar -xzvf /mnt/pmem/pm0/twitter7.tar.gz
+./SNAPtoAdj -s /mnt/pmem/pm0/twitter7.txt /mnt/pmem/pm0/twitter7
+
